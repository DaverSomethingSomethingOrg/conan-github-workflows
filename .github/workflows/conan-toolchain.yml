######################################################################
# conan-toolchain.yml
#
# Copyright Â© 2025 David L. Armstrong
#
# This workflow will process a single "toolchain" conanfile.py build.
# Special provisions are made for delivering multiple packages at once.
#
# For more information see:
# - https://github.com/DaverSomethingSomethingOrg/conan-github-workflows
# - https://docs.conan.io/2/tutorial/developing_packages/local_package_development_flow.html
#

# https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#example-including-paths

name: Conan C/C++ toolchain build

on:
  workflow_call:
    inputs:
      runner_selection:
        type: string
        default: self-hosted
      component_subdirectory:
        type: string
        default: "src"
      restore_cache_key:
        type: string
      save_cache_key:
        type: string
      conan_home:
        type: string
      conan_local_recipes:
        type: string
      conan_local_repo:
        type: string
      conan_center_proxy:
        type: string
      container_image:
        type: string
        default: "nexus.homelab/conan-build-almalinux:aarch64-latest"
      conan_profile:
        type: string
        default:
      conan_deployer_repo:
        type: string
        default: https://github.com/DaverSomethingSomethingOrg/conan-system-packaging.git
      conan_deployer:
        type: string
        default: 'deb_deployer'
      conan_profile_repo:
        type: string
        default:  # conan images should come with default profile installed.. good enough for most cases
      toolchain_prefix:
        type: string
        required: true
      is_enabled:
        type: boolean
        default: true
      upload_packages:
        type: boolean
        default: false

jobs:
  toolchain_build:
    if: ${{ inputs.is_enabled }}
    runs-on: ${{ inputs.runner_selection }}
    container:
      image: ${{ inputs.container_image }}
      credentials:
#        username: ${{ github.actor }}
#        password: ${{ secrets.GITHUB_TOKEN }}
        username: ${{ vars.NEXUS_CI_USER }}
        password: ${{ secrets.NEXUS_CI_PASSWORD }}

    steps:
    - uses: actions/checkout@v4
      with:
        submodules: true

    # We do this dynamically to reduce #inputs
    # We can get away with this because we know how our deployer works here.
    - name: Configure Workflow Environment
      id: configure_workflow_environment
      run: |
        if [ "${{ inputs.conan_deployer }}" = "deb_deployer" ]; then
          echo "CACHE_PACKAGE_PATHS=*.deb" >> $GITHUB_ENV
        elif [ "${{ inputs.conan_deployer }}" = "rpm_deployer" ]; then
          echo "CACHE_PACKAGE_PATHS=RPM_HOME/rpmbuild/RPMS/*/*" >> $GITHUB_ENV
        else
          echo "ERROR: Unsupported Conan Deployer: '${{ inputs.conan_deployer }}'"
          exit 1
        fi

    - name: Restore Deployed Packages from Cache
      if: ${{ inputs.restore_cache_key }}
      uses: actions/cache/restore@v4
      with:
        path: |
          package_deploy/${{ env.CACHE_PACKAGE_PATHS }}
        key: ${{ inputs.restore_cache_key }}

    - name: Install Cached RPM Packages
      if: ${{ inputs.restore_cache_key
       && inputs.conan_deployer == 'rpm_deployer'
       && hashFiles('package_deploy/${{ env.CACHE_PACKAGE_PATHS }}') != '' }}
      run: |
        echo "Installing:"
        for package in package_deploy/${{ env.CACHE_PACKAGE_PATHS }}; do
          printf '    %s\n' "${package}"
        done
        rpm --install --package package_deploy/${{ env.CACHE_PACKAGE_PATHS }}
        echo "${{ inputs.toolchain_prefix }}/bin" >> $GITHUB_PATH
        echo "New GITHUB_PATH:"
        while IFS= read -r line; do printf '    %s\n' "${line}"; done < $GITHUB_PATH

    - name: Install Cached .deb Packages
      if: ${{ inputs.restore_cache_key
       && inputs.conan_deployer == 'deb_deployer'
       && hashFiles('package_deploy/${{ env.CACHE_PACKAGE_PATHS }}') != '' }}
      run: |
        echo "Installing:"
        for package in package_deploy/${{ env.CACHE_PACKAGE_PATHS }}; do
          printf '    %s\n' "${package}"
        done
        dpkg --install package_deploy/${{ env.CACHE_PACKAGE_PATHS }}
        echo "${{ inputs.toolchain_prefix }}/bin" >> $GITHUB_PATH
        echo "New GITHUB_PATH:"
        while IFS= read -r line; do printf '    %s\n' "${line}"; done < $GITHUB_PATH

# TODO - `pip install conan` doesn't work here on Ubuntu system python
#   without `--break-system-packages` even though we don't need it
#  
#    - name: Install and setup Conan
#      uses: conan-io/setup-conan@v1
#      with:
#         home: "${{ github.workspace }}/CONAN_HOME"
#         config_urls: |
#           ${{ inputs.conan_deployer_repo }} \
#           ${{ inputs.conan_profile_repo }}
##        audit_token: ${{ secrets.MY_CONAN_AUDIT_TOKEN }}

    - name: Setup Conan Home
      run: |
        if [ -n "${{ inputs.conan_home }}" ]; then
          echo "CONAN_HOME=${{ inputs.conan_home }}" >> $GITHUB_ENV
        else
          echo "CONAN_HOME=${{ github.workspace }}/CONAN_HOME" >> $GITHUB_ENV
        fi

    - name: Setup Conan Default Profile and Profile Repo
      run: |
        if [ -z "${{ inputs.conan_profile }}" ]; then
          # Make sure we have a default profile ready .. GitHub Actions uses a custom $HOME
          conan profile detect --force
        fi
        if [ -n "${{ inputs.conan_profile_repo }}" ]; then
          conan config install ${{ inputs.conan_profile_repo }}
        fi

    - name: Setup Conan Toolchain Deployers
      run: |
        conan config install ${{ inputs.conan_deployer_repo }}

    - name: Setup Conan Recipe Remotes
      run: |
        if [ -n "${{ inputs.conan_center_proxy }}" ]; then
          conan remote disable conancenter
          conan remote add conan-center-proxy "${{ inputs.conan_center_proxy }}"
          conan remote update conan-center-proxy --index 0
        fi

        if [ -n "${{ inputs.conan_local_recipes }}" ]; then
          conan remote remove conan-local-recipes >/dev/null 2>&1 || /bin/true
          conan remote add -t local-recipes-index conan-local-recipes "${{ inputs.conan_local_recipes }}"
          conan remote update conan-local-recipes --index 0
        fi

        if [ -n "${{ inputs.conan_local_repo }}" ]; then
          conan remote remove conan-local-repo >/dev/null 2>&1 || /bin/true
          conan remote add conan-local-repo "${{ inputs.conan_local_repo }}"
          conan remote update conan-local-repo --index 0
        fi

        conan remote list

#    - name: Scan for vulnerabilities with Conan Audit
#      run: |
#        conan audit scan "${{ inputs.component_subdirectory }}"

    - name: Build and Cache all tools and dependencies
      run: |
        echo "PATH: ${PATH}"
        conan install \
          --build=missing \
          --options="*:install_prefix=${{ inputs.toolchain_prefix }}" \
          "${{ inputs.component_subdirectory }}"

    - name: System Package Deployer
      run: |
        echo "PATH: ${PATH}"
        conan install \
          --deployer-folder=package_deploy \
          --deployer="${{ inputs.conan_deployer }}" \
          --options="*:install_prefix=${{ inputs.toolchain_prefix }}" \
          "${{ inputs.component_subdirectory }}"

    - name: Save Deployed Packages to Cache
      if: ${{ inputs.save_cache_key }}
      uses: actions/cache/save@v4
      with:
        path: |
          package_deploy/${{ env.CACHE_PACKAGE_PATHS }}
        key: ${{ inputs.save_cache_key }}

    - name: Upload RPM Packages to Artifact Management
      if: ${{ inputs.upload_packages
       && inputs.conan_deployer == 'rpm_deployer'
       && hashFiles('package_deploy/${{ env.CACHE_PACKAGE_PATHS }}') != '' }}
      shell: bash
      env:
        NEXUS_CI_PASSWORD: ${{ secrets.NEXUS_CI_PASSWORD }}
        NEXUS_CI_USER: ${{ vars.NEXUS_CI_USER }}
        NEXUS_SERVER: ${{ vars.NEXUS_SERVER }}
        NEXUS_YUM_REPO: ${{ vars.NEXUS_YUM_REPO }}
      run: |
        . /etc/os-release
        UPLOAD_PACKAGES_SUBDIR="conan-toolchain/${ID}/${VERSION_ID}"
        RPM_DEPLOY_DIR="package_deploy/RPM_HOME/rpmbuild/RPMS"

        echo "Uploading:"
        for package in ${RPM_DEPLOY_DIR}/*/*; do
          rpm_file=$(basename "${package}")
          arch_dir=$(dirname "${package}")
          arch=$(basename "${arch_dir}")
          printf '    %s\n' "${package}"

          curl --insecure \
               --user "${NEXUS_CI_USER}:${NEXUS_CI_PASSWORD}" \
               --upload-file "${package}" \
               "${NEXUS_SERVER}/repository/${NEXUS_YUM_REPO}/${UPLOAD_PACKAGES_SUBDIR}/${arch}/Packages/${rpm_file}"
        done

        # trigger repo re-index
        echo "Triggering Repository index rebuild.."
        curl --insecure \
             --user "${NEXUS_CI_USER}:${NEXUS_CI_PASSWORD}" \
             "${NEXUS_SERVER}/service/rest/v1/repositories/${NEXUS_YUM_REPO}/rebuild-index"

        echo "Done."

    - name: Upload Debian Packages to Artifact Management
      if: ${{ inputs.upload_packages
       && inputs.conan_deployer == 'deb_deployer'
       && hashFiles('package_deploy/${{ env.CACHE_PACKAGE_PATHS }}') != '' }}
      shell: bash
      env:
        NEXUS_CI_PASSWORD: ${{ secrets.NEXUS_CI_PASSWORD }}
        NEXUS_CI_USER: ${{ vars.NEXUS_CI_USER }}
        NEXUS_SERVER: ${{ vars.NEXUS_SERVER }}
        NEXUS_APT_REPO: ${{ vars.NEXUS_APT_REPO }}
      run: |
        echo "Uploading:"
        for package in package_deploy/${CACHE_PACKAGE_PATHS}; do
          printf '    %s\n' "${package}"

          # Adapted from:
          # https://help.sonatype.com/en/apt-repositories.html#deploying-packages-to-hosted-apt-repositories
          curl \
             --user "${NEXUS_CI_USER}:${NEXUS_CI_PASSWORD}" \
             --header "Content-Type: multipart/form-data" \
             --data-binary "@./${package}" \
             "${NEXUS_SERVER}/repository/${NEXUS_APT_REPO}/"

        done

        # trigger repo re-index
        echo "Triggering Repository index rebuild.."
 
        curl \
             --user "${NEXUS_CI_USER}:${NEXUS_CI_PASSWORD}" \
             "${NEXUS_SERVER}/service/rest/v1/repositories/${NEXUS_APT_REPO}/rebuild-index"

        echo "Done."
